/* tslint:disable */
/* eslint-disable */
/**
 * IRIS-Gateway API
 * ### Encryption of the data to be transmitted (contact data) In order to be not limited in the amount of data, a hybrid encryption with symmetric encryption of the data and asymmetric encryption of the symmetric key is used for the encryption of the contact data.    1. The apps and applications get the public key of the health department as a 4096-bit RSA key from the IRIS+ server. This key is base64-encoded in the Private Enhanced Mail (PEM) format.   2. The app generates a 256-bit AES key.   3. With this key the data is encrypted (algorithm: AES).   4. The AES key must be encrypted with the public RSA key of the health department. (algorithm: RSA with Optimal Asymmetric Encryption Padding (OAEP))   5. The encrypted AES key and the encrypted content must be transmitted base64 encoded.    #### Schematic sequence    ```   pubKeyEncryption = publicKeyFromPem(givenPublicKey);   contentKey = generateAESKey();    encrypted = contentKey.encrypt(content);   keyEncrypted = pubKeyEncryption.encrypt(contentKey, \"RSA/NONE/OAEPWithSHA3-256AndMGF1Padding\");    dataToTransport = base64Encode(encrypted);   keyToTransport = base64Encode(keyEncrypted);   ``` 
 *
 * The version of the OpenAPI document: 0.2.0
 * Contact: jens.kutzsche@gebea.de
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    street?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    houseNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    zipCode?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    city?: string;
}
/**
 * Category of contact that describes the intensity and thus the risk of infection of the contact.
 * @export
 * @enum {string}
 */
export enum ContactCategory {
    HighRisk = 'HIGH_RISK',
    HighRiskMed = 'HIGH_RISK_MED',
    MediumRiskMed = 'MEDIUM_RISK_MED',
    LowRisk = 'LOW_RISK',
    NoRisk = 'NO_RISK'
}

/**
 * Extended person data type for contact persons who had contact with the queried person during the queried time.
 * @export
 * @interface ContactPerson
 */
export interface ContactPerson {
    /**
     * 
     * @type {string}
     * @memberof ContactPerson
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof ContactPerson
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof ContactPerson
     */
    dateOfBirth?: string;
    /**
     * 
     * @type {Sex}
     * @memberof ContactPerson
     */
    sex?: Sex;
    /**
     * 
     * @type {string}
     * @memberof ContactPerson
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactPerson
     */
    phone?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactPerson
     */
    mobilePhone?: string;
    /**
     * 
     * @type {Address}
     * @memberof ContactPerson
     */
    address?: Address | null;
    /**
     * 
     * @type {ContactPersonAllOfWorkPlace}
     * @memberof ContactPerson
     */
    workPlace?: ContactPersonAllOfWorkPlace;
    /**
     * 
     * @type {ContactPersonAllOfContactInformation}
     * @memberof ContactPerson
     */
    contactInformation?: ContactPersonAllOfContactInformation;
}
/**
 * 
 * @export
 * @interface ContactPersonAllOf
 */
export interface ContactPersonAllOf {
    /**
     * 
     * @type {ContactPersonAllOfWorkPlace}
     * @memberof ContactPersonAllOf
     */
    workPlace?: ContactPersonAllOfWorkPlace;
    /**
     * 
     * @type {ContactPersonAllOfContactInformation}
     * @memberof ContactPersonAllOf
     */
    contactInformation?: ContactPersonAllOfContactInformation;
}
/**
 * Additional informations about the contact(s) with the queried person.
 * @export
 * @interface ContactPersonAllOfContactInformation
 */
export interface ContactPersonAllOfContactInformation {
    /**
     * 
     * @type {string}
     * @memberof ContactPersonAllOfContactInformation
     */
    firstContactDate?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactPersonAllOfContactInformation
     */
    lastContactDate?: string;
    /**
     * 
     * @type {ContactCategory}
     * @memberof ContactPersonAllOfContactInformation
     */
    contactCategory?: ContactCategory | null;
    /**
     * Informations about the basic conditions such as: from, to, place, inside|outside, mask yes|no, distance >=|< 1,5m, ventilated yes|no, remarks.
     * @type {string}
     * @memberof ContactPersonAllOfContactInformation
     */
    basicConditions?: string;
}
/**
 * Additional informations about the work place of the contact person.
 * @export
 * @interface ContactPersonAllOfWorkPlace
 */
export interface ContactPersonAllOfWorkPlace {
    /**
     * Name of work place
     * @type {string}
     * @memberof ContactPersonAllOfWorkPlace
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactPersonAllOfWorkPlace
     */
    pointOfContact?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactPersonAllOfWorkPlace
     */
    phone?: string;
    /**
     * 
     * @type {Address}
     * @memberof ContactPersonAllOfWorkPlace
     */
    address?: Address | null;
}
/**
 * A collection of contact persons who had contact with the queried person during the queried time. This data must be encrypted with the key of health department from DataRequest.keyOfHealthDepartment and must be encoded with Base64!
 * @export
 * @interface ContactPersonList
 */
export interface ContactPersonList {
    /**
     * 
     * @type {Array<ContactPerson>}
     * @memberof ContactPersonList
     */
    contactPersons: Array<ContactPerson>;
    /**
     * Start date of contacts for this list.
     * @type {string}
     * @memberof ContactPersonList
     */
    startDate?: string;
    /**
     * End date of contacts for this list.
     * @type {string}
     * @memberof ContactPersonList
     */
    endDate?: string;
}
/**
 * This data must be encrypted with the key of health department from DataRequest.keyOfHealthDepartment and must be encoded with Base64!(`dataToTransport` in the general description of the API.)
 * @export
 * @interface ContactsAndEvents
 */
export interface ContactsAndEvents {
    /**
     * 
     * @type {ContactPersonList}
     * @memberof ContactsAndEvents
     */
    contacts: ContactPersonList;
    /**
     * 
     * @type {EventList}
     * @memberof ContactsAndEvents
     */
    events: EventList;
    /**
     * 
     * @type {ContactsAndEventsDataProvider}
     * @memberof ContactsAndEvents
     */
    dataProvider: ContactsAndEventsDataProvider;
}
/**
 * 
 * @export
 * @interface ContactsAndEventsDataProvider
 */
export interface ContactsAndEventsDataProvider {
    /**
     * 
     * @type {string}
     * @memberof ContactsAndEventsDataProvider
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof ContactsAndEventsDataProvider
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof ContactsAndEventsDataProvider
     */
    dateOfBirth: string;
}
/**
 * 
 * @export
 * @interface ContactsEventsSubmission
 */
export interface ContactsEventsSubmission {
    /**
     * The encrypted secret key for encryption. (`keyToTransport` in the general description of the API.)
     * @type {string}
     * @memberof ContactsEventsSubmission
     */
    secret: string;
    /**
     * Reference to the used encryption key. This must be the value from keyReference of the DataRequest as this matches the passed and thus used key.
     * @type {string}
     * @memberof ContactsEventsSubmission
     */
    keyReference: string;
    /**
     * 
     * @type {ContactsAndEvents}
     * @memberof ContactsEventsSubmission
     */
    encryptedData: ContactsAndEvents;
}
/**
 * 
 * @export
 * @interface ContactsEventsSubmissionAllOf
 */
export interface ContactsEventsSubmissionAllOf {
    /**
     * 
     * @type {ContactsAndEvents}
     * @memberof ContactsEventsSubmissionAllOf
     */
    encryptedData: ContactsAndEvents;
}
/**
 * A data request with all parameters relevant for the data submission.
 * @export
 * @interface DataRequest
 */
export interface DataRequest {
    /**
     * Name of the requesting health department.
     * @type {string}
     * @memberof DataRequest
     */
    healthDepartment: string;
    /**
     * The key of the requesting health department that must be used for encryption. The key is encoded with Base64.
     * @type {string}
     * @memberof DataRequest
     */
    keyOfHealthDepartment: string;
    /**
     * Reference id of the given key. This reference must be included in the submission in order to identify the correct private key for decryption at the health department.
     * @type {string}
     * @memberof DataRequest
     */
    keyReference: string;
    /**
     * The start time for which data should be submitted with this request.
     * @type {string}
     * @memberof DataRequest
     */
    start: string;
    /**
     * The end time for which data should be submitted with this request.
     * @type {string}
     * @memberof DataRequest
     */
    end?: string;
    /**
     * Details of the data request, specifying it in more detail and narrowing down the data to be provided (e.g. table and environment, seat, rank, ...).
     * @type {string}
     * @memberof DataRequest
     */
    requestDetails?: string;
}
/**
 * The data request that will be sent by the FE.
 * @export
 * @interface DataRequestClient
 */
export interface DataRequestClient {
    /**
     * Id of the location to request the data from.
     * @type {string}
     * @memberof DataRequestClient
     */
    locationId: string;
    /**
     * ID of the App provider serving the location.
     * @type {string}
     * @memberof DataRequestClient
     */
    providerId: string;
    /**
     * Friendly name of the request to be identified easily by GA
     * @type {string}
     * @memberof DataRequestClient
     */
    name: string;
    /**
     * External ID outside of IRIS
     * @type {string}
     * @memberof DataRequestClient
     */
    externalRequestId: string;
    /**
     * The start time for which data should be submitted with this request.
     * @type {string}
     * @memberof DataRequestClient
     */
    start: string;
    /**
     * The end time for which data should be submitted with this request.
     * @type {string}
     * @memberof DataRequestClient
     */
    end: string;
    /**
     * Details of the data request, specifying it in more detail and narrowing down the data to be provided (e.g. table and environment, seat, rank, ...).
     * @type {string}
     * @memberof DataRequestClient
     */
    requestDetails?: string;
}
/**
 * 
 * @export
 * @interface DataRequestDetails
 */
export interface DataRequestDetails {
    /**
     * 
     * @type {string}
     * @memberof DataRequestDetails
     */
    status?: DataRequestDetailsStatusEnum;
    /**
     * Code for DataRequest
     * @type {string}
     * @memberof DataRequestDetails
     */
    code?: string;
    /**
     * Friendly name of the request to be identified easily by GA
     * @type {string}
     * @memberof DataRequestDetails
     */
    name?: string;
    /**
     * External ID outside of IRIS
     * @type {string}
     * @memberof DataRequestDetails
     */
    externalRequestId?: string;
    /**
     * The start time for which data should be submitted with this request.
     * @type {string}
     * @memberof DataRequestDetails
     */
    start?: string;
    /**
     * The end time for which data should be submitted with this request.
     * @type {string}
     * @memberof DataRequestDetails
     */
    end?: string;
    /**
     * Timestamp when the data request was created.
     * @type {string}
     * @memberof DataRequestDetails
     */
    requestedAt?: string;
    /**
     * Timestamp when the data request was last updated.
     * @type {string}
     * @memberof DataRequestDetails
     */
    lastUpdatedAt?: string;
    /**
     * Details of the data request, specifying it in more detail and narrowing down the data to be provided (e.g. table and environment, seat, rank, ...).
     * @type {string}
     * @memberof DataRequestDetails
     */
    requestDetails?: string;
    /**
     * 
     * @type {LocationInformation}
     * @memberof DataRequestDetails
     */
    locationInformation?: LocationInformation;
    /**
     * 
     * @type {Array<Guest>}
     * @memberof DataRequestDetails
     */
    guests: Array<Guest>;
    /**
     * 
     * @type {GuestListDataProvider}
     * @memberof DataRequestDetails
     */
    dataProvider: GuestListDataProvider;
    /**
     * Additional informations about the guest list and the event or location.
     * @type {string}
     * @memberof DataRequestDetails
     */
    additionalInformation?: string;
    /**
     * Start date/time of attendance for this guest list.
     * @type {string}
     * @memberof DataRequestDetails
     */
    startDate?: string;
    /**
     * End date/time of attendance for this guest list.
     * @type {string}
     * @memberof DataRequestDetails
     */
    endDate?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum DataRequestDetailsStatusEnum {
    DataRequested = 'DATA_REQUESTED',
    DataReceived = 'DATA_RECEIVED',
    Closed = 'CLOSED'
}

/**
 * Basic data type of a data submission which contains the unencrypted metadata needed for processing.
 * @export
 * @interface DataSubmission
 */
export interface DataSubmission {
    /**
     * The encrypted secret key for encryption. (`keyToTransport` in the general description of the API.)
     * @type {string}
     * @memberof DataSubmission
     */
    secret: string;
    /**
     * Reference to the used encryption key. This must be the value from keyReference of the DataRequest as this matches the passed and thus used key.
     * @type {string}
     * @memberof DataSubmission
     */
    keyReference: string;
}
/**
 * An event, location or occasion visited by the queried person during the queried time.
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * Name of the event
     * @type {string}
     * @memberof Event
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    phone?: string;
    /**
     * 
     * @type {Address}
     * @memberof Event
     */
    address?: Address | null;
    /**
     * Additional informations about the event.
     * @type {string}
     * @memberof Event
     */
    additionalInformation?: string;
}
/**
 * A collection of events visited by the queried person during the queried time. This data must be encrypted with the key of health department from DataRequest.keyOfHealthDepartment and must be encoded with Base64!
 * @export
 * @interface EventList
 */
export interface EventList {
    /**
     * 
     * @type {Array<Event>}
     * @memberof EventList
     */
    events: Array<Event>;
    /**
     * Start date of visits for this list.
     * @type {string}
     * @memberof EventList
     */
    startDate?: string;
    /**
     * End date of visits for this list.
     * @type {string}
     * @memberof EventList
     */
    endDate?: string;
}
/**
 * 
 * @export
 * @interface ExistingDataRequestClientWithLocation
 */
export interface ExistingDataRequestClientWithLocation {
    /**
     * 
     * @type {string}
     * @memberof ExistingDataRequestClientWithLocation
     */
    status?: ExistingDataRequestClientWithLocationStatusEnum;
    /**
     * Code for DataRequest
     * @type {string}
     * @memberof ExistingDataRequestClientWithLocation
     */
    code?: string;
    /**
     * Friendly name of the request to be identified easily by GA
     * @type {string}
     * @memberof ExistingDataRequestClientWithLocation
     */
    name?: string;
    /**
     * External ID outside of IRIS
     * @type {string}
     * @memberof ExistingDataRequestClientWithLocation
     */
    externalRequestId?: string;
    /**
     * The start time for which data should be submitted with this request.
     * @type {string}
     * @memberof ExistingDataRequestClientWithLocation
     */
    start?: string;
    /**
     * The end time for which data should be submitted with this request.
     * @type {string}
     * @memberof ExistingDataRequestClientWithLocation
     */
    end?: string;
    /**
     * Timestamp when the data request was created.
     * @type {string}
     * @memberof ExistingDataRequestClientWithLocation
     */
    requestedAt?: string;
    /**
     * Timestamp when the data request was last updated.
     * @type {string}
     * @memberof ExistingDataRequestClientWithLocation
     */
    lastUpdatedAt?: string;
    /**
     * Details of the data request, specifying it in more detail and narrowing down the data to be provided (e.g. table and environment, seat, rank, ...).
     * @type {string}
     * @memberof ExistingDataRequestClientWithLocation
     */
    requestDetails?: string;
    /**
     * 
     * @type {LocationInformation}
     * @memberof ExistingDataRequestClientWithLocation
     */
    locationInformation?: LocationInformation;
}

/**
    * @export
    * @enum {string}
    */
export enum ExistingDataRequestClientWithLocationStatusEnum {
    DataRequested = 'DATA_REQUESTED',
    DataReceived = 'DATA_RECEIVED',
    Closed = 'CLOSED'
}

/**
 * 
 * @export
 * @interface ExistingDataRequestClientWithLocationList
 */
export interface ExistingDataRequestClientWithLocationList {
    /**
     * 
     * @type {Array<ExistingDataRequestClientWithLocation>}
     * @memberof ExistingDataRequestClientWithLocationList
     */
    dataRequests?: Array<ExistingDataRequestClientWithLocation>;
}
/**
 * Extended person data type for a guest who attended a queried event or location in the queried time.
 * @export
 * @interface Guest
 */
export interface Guest {
    /**
     * 
     * @type {string}
     * @memberof Guest
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof Guest
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof Guest
     */
    dateOfBirth?: string;
    /**
     * 
     * @type {Sex}
     * @memberof Guest
     */
    sex?: Sex;
    /**
     * 
     * @type {string}
     * @memberof Guest
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof Guest
     */
    phone?: string;
    /**
     * 
     * @type {string}
     * @memberof Guest
     */
    mobilePhone?: string;
    /**
     * 
     * @type {Address}
     * @memberof Guest
     */
    address?: Address | null;
    /**
     * 
     * @type {GuestAllOfAttendanceInformation}
     * @memberof Guest
     */
    attendanceInformation: GuestAllOfAttendanceInformation;
    /**
     * The app indicates whether the data are verified with respect to identity (e.g. by phone number) = TRUE or whether they are unverified form inputs = FALSE.
     * @type {boolean}
     * @memberof Guest
     */
    identityChecked?: boolean;
}
/**
 * 
 * @export
 * @interface GuestAllOf
 */
export interface GuestAllOf {
    /**
     * 
     * @type {GuestAllOfAttendanceInformation}
     * @memberof GuestAllOf
     */
    attendanceInformation: GuestAllOfAttendanceInformation;
    /**
     * The app indicates whether the data are verified with respect to identity (e.g. by phone number) = TRUE or whether they are unverified form inputs = FALSE.
     * @type {boolean}
     * @memberof GuestAllOf
     */
    identityChecked?: boolean;
}
/**
 * 
 * @export
 * @interface GuestAllOfAttendanceInformation
 */
export interface GuestAllOfAttendanceInformation {
    /**
     * Description of the type of participation.
     * @type {string}
     * @memberof GuestAllOfAttendanceInformation
     */
    descriptionOfParticipation?: string;
    /**
     * Start date/time of attendance of this guest.
     * @type {string}
     * @memberof GuestAllOfAttendanceInformation
     */
    attendFrom: string;
    /**
     * End date/time of attendance of this guest.
     * @type {string}
     * @memberof GuestAllOfAttendanceInformation
     */
    attendTo: string;
    /**
     * Additional informations about the attendance.
     * @type {string}
     * @memberof GuestAllOfAttendanceInformation
     */
    additionalInformation?: string;
}
/**
 * A collection of guests who attended a queried event or location in the queried time. This data must be encrypted with the key of health department from DataRequest.keyOfHealthDepartment and must be encoded with Base64! (`dataToTransport` in the general description of the API.)
 * @export
 * @interface GuestList
 */
export interface GuestList {
    /**
     * 
     * @type {Array<Guest>}
     * @memberof GuestList
     */
    guests: Array<Guest>;
    /**
     * 
     * @type {GuestListDataProvider}
     * @memberof GuestList
     */
    dataProvider: GuestListDataProvider;
    /**
     * Additional informations about the guest list and the event or location.
     * @type {string}
     * @memberof GuestList
     */
    additionalInformation?: string;
    /**
     * Start date/time of attendance for this guest list.
     * @type {string}
     * @memberof GuestList
     */
    startDate?: string;
    /**
     * End date/time of attendance for this guest list.
     * @type {string}
     * @memberof GuestList
     */
    endDate?: string;
}
/**
 * 
 * @export
 * @interface GuestListDataProvider
 */
export interface GuestListDataProvider {
    /**
     * Name of Location, Institution or Organizer
     * @type {string}
     * @memberof GuestListDataProvider
     */
    name: string;
    /**
     * 
     * @type {Address}
     * @memberof GuestListDataProvider
     */
    address: Address;
}
/**
 * 
 * @export
 * @interface GuestsSubmission
 */
export interface GuestsSubmission {
    /**
     * The encrypted secret key for encryption. (`keyToTransport` in the general description of the API.)
     * @type {string}
     * @memberof GuestsSubmission
     */
    secret: string;
    /**
     * Reference to the used encryption key. This must be the value from keyReference of the DataRequest as this matches the passed and thus used key.
     * @type {string}
     * @memberof GuestsSubmission
     */
    keyReference: string;
    /**
     * 
     * @type {GuestList}
     * @memberof GuestsSubmission
     */
    encryptedData: GuestList;
}
/**
 * 
 * @export
 * @interface GuestsSubmissionAllOf
 */
export interface GuestsSubmissionAllOf {
    /**
     * 
     * @type {GuestList}
     * @memberof GuestsSubmissionAllOf
     */
    encryptedData: GuestList;
}
/**
 * Anschrift des Standorts
 * @export
 * @interface LocationAddress
 */
export interface LocationAddress {
    /**
     * street + number
     * @type {string}
     * @memberof LocationAddress
     */
    street: string;
    /**
     * Stadt
     * @type {string}
     * @memberof LocationAddress
     */
    city: string;
    /**
     * Postleitzahl
     * @type {string}
     * @memberof LocationAddress
     */
    zip: string;
}
/**
 * Kontaktperson des Standorts
 * @export
 * @interface LocationContact
 */
export interface LocationContact {
    /**
     * Offizieller Unternehmensname
     * @type {string}
     * @memberof LocationContact
     */
    officialName?: string;
    /**
     * Ansprechpartner für dieses Unternehmen
     * @type {string}
     * @memberof LocationContact
     */
    representative?: string;
    /**
     * 
     * @type {LocationAddress}
     * @memberof LocationContact
     */
    address: LocationAddress;
    /**
     * E-Mail des Inhabers
     * @type {string}
     * @memberof LocationContact
     */
    ownerEmail?: string;
    /**
     * ggf. E-Mail einer weiteren Kontaktperson
     * @type {string}
     * @memberof LocationContact
     */
    email?: string;
    /**
     * Telefonnummer eines Ansprechpartners
     * @type {string}
     * @memberof LocationContact
     */
    phone?: string;
}
/**
 * Ein Standort hat ggf. weitere Informationen wie Tische/Räume, etc.
 * @export
 * @interface LocationContext
 */
export interface LocationContext {
    /**
     * Interne ID des Kontext
     * @type {string}
     * @memberof LocationContext
     */
    id: string;
    /**
     * Bezeichnung
     * @type {string}
     * @memberof LocationContext
     */
    name: string;
}
/**
 * All information needed to create a new TracingTicket
 * @export
 * @interface LocationDataRequest
 */
export interface LocationDataRequest {
    /**
     * The URI that can be used to submit contact data for this tracing code.
     * @type {string}
     * @memberof LocationDataRequest
     */
    submissionUri: string;
    /**
     * The id of the location.
     * @type {string}
     * @memberof LocationDataRequest
     */
    locationId: string;
    /**
     * Name of the requesting health department.
     * @type {string}
     * @memberof LocationDataRequest
     */
    healthDepartment: string;
    /**
     * The key of the requesting health department that must be used for encryption. The key is encoded with Base64.
     * @type {string}
     * @memberof LocationDataRequest
     */
    keyOfHealthDepartment: string;
    /**
     * Reference id of the given key. This reference must be included in the submission in order to identify the correct private key for decryption at the health department.
     * @type {string}
     * @memberof LocationDataRequest
     */
    keyReference: string;
    /**
     * The start time for which data should be submitted with this request.
     * @type {string}
     * @memberof LocationDataRequest
     */
    start: string;
    /**
     * The end time for which data should be submitted with this request.
     * @type {string}
     * @memberof LocationDataRequest
     */
    end: string;
    /**
     * Details of the data request, specifying it in more detail and narrowing down the data to be provided (e.g. table and environment, seat, rank, ...).
     * @type {string}
     * @memberof LocationDataRequest
     */
    requestDetails?: string;
}
/**
 * 
 * @export
 * @interface LocationInformation
 */
export interface LocationInformation {
    /**
     * Interne ID (beim Provider)
     * @type {string}
     * @memberof LocationInformation
     */
    id: string;
    /**
     * ID des App providers
     * @type {string}
     * @memberof LocationInformation
     */
    providerId: string;
    /**
     * Name des Standorts
     * @type {string}
     * @memberof LocationInformation
     */
    name: string;
    /**
     * Öffentlicher Schlüssel, ggf. für Nachrichtenaustausch
     * @type {string}
     * @memberof LocationInformation
     */
    publicKey?: string;
    /**
     * 
     * @type {LocationContact}
     * @memberof LocationInformation
     */
    contact: LocationContact;
    /**
     * 
     * @type {Array<LocationContext>}
     * @memberof LocationInformation
     */
    contexts?: Array<LocationContext>;
}
/**
 * 
 * @export
 * @interface LocationList
 */
export interface LocationList {
    /**
     * 
     * @type {Array<LocationInformation>}
     * @memberof LocationList
     */
    locations: Array<LocationInformation>;
}
/**
 * Basic data type of a person.
 * @export
 * @interface Person
 */
export interface Person {
    /**
     * 
     * @type {string}
     * @memberof Person
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof Person
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof Person
     */
    dateOfBirth?: string;
    /**
     * 
     * @type {Sex}
     * @memberof Person
     */
    sex?: Sex;
    /**
     * 
     * @type {string}
     * @memberof Person
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof Person
     */
    phone?: string;
    /**
     * 
     * @type {string}
     * @memberof Person
     */
    mobilePhone?: string;
    /**
     * 
     * @type {Address}
     * @memberof Person
     */
    address?: Address | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Sex {
    Male = 'MALE',
    Female = 'FEMALE',
    Other = 'OTHER',
    Unknown = 'UNKNOWN'
}


/**
 * IrisClientFrontendApi - axios parameter creator
 * @export
 */
export const IrisClientFrontendApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Fetches data requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataRequestsClientLocationsGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/data-requests-client/locations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-IRIS-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Submits a new data request
         * @param {DataRequestClient} dataRequestClient 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataRequestsClientLocationsPost: async (dataRequestClient: DataRequestClient, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataRequestClient' is not null or undefined
            assertParamExists('dataRequestsClientLocationsPost', 'dataRequestClient', dataRequestClient)
            const localVarPath = `/data-requests-client/locations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-IRIS-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=UTF-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataRequestClient, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Detail view for Data Request with the data submissions already received
         * @param {string} code The unique code of a data request in format of a UUID sent by the health department.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLocationDetails: async (code: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('getLocationDetails', 'code', code)
            const localVarPath = `/data-requests-client/locations/{code}`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-IRIS-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} searchKeyword The search keyword
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchSearchKeywordGet: async (searchKeyword: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchKeyword' is not null or undefined
            assertParamExists('searchSearchKeywordGet', 'searchKeyword', searchKeyword)
            const localVarPath = `/search/{search_keyword}`
                .replace(`{${"search_keyword"}}`, encodeURIComponent(String(searchKeyword)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-IRIS-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IrisClientFrontendApi - functional programming interface
 * @export
 */
export const IrisClientFrontendApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IrisClientFrontendApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Fetches data requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataRequestsClientLocationsGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExistingDataRequestClientWithLocationList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataRequestsClientLocationsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Submits a new data request
         * @param {DataRequestClient} dataRequestClient 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataRequestsClientLocationsPost(dataRequestClient: DataRequestClient, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataRequestDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataRequestsClientLocationsPost(dataRequestClient, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Detail view for Data Request with the data submissions already received
         * @param {string} code The unique code of a data request in format of a UUID sent by the health department.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLocationDetails(code: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataRequestDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLocationDetails(code, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} searchKeyword The search keyword
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchSearchKeywordGet(searchKeyword: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchSearchKeywordGet(searchKeyword, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IrisClientFrontendApi - factory interface
 * @export
 */
export const IrisClientFrontendApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IrisClientFrontendApiFp(configuration)
    return {
        /**
         * 
         * @summary Fetches data requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataRequestsClientLocationsGet(options?: any): AxiosPromise<ExistingDataRequestClientWithLocationList> {
            return localVarFp.dataRequestsClientLocationsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Submits a new data request
         * @param {DataRequestClient} dataRequestClient 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataRequestsClientLocationsPost(dataRequestClient: DataRequestClient, options?: any): AxiosPromise<DataRequestDetails> {
            return localVarFp.dataRequestsClientLocationsPost(dataRequestClient, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Detail view for Data Request with the data submissions already received
         * @param {string} code The unique code of a data request in format of a UUID sent by the health department.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLocationDetails(code: string, options?: any): AxiosPromise<DataRequestDetails> {
            return localVarFp.getLocationDetails(code, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} searchKeyword The search keyword
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchSearchKeywordGet(searchKeyword: string, options?: any): AxiosPromise<LocationList> {
            return localVarFp.searchSearchKeywordGet(searchKeyword, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IrisClientFrontendApi - object-oriented interface
 * @export
 * @class IrisClientFrontendApi
 * @extends {BaseAPI}
 */
export class IrisClientFrontendApi extends BaseAPI {
    /**
     * 
     * @summary Fetches data requests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IrisClientFrontendApi
     */
    public dataRequestsClientLocationsGet(options?: any) {
        return IrisClientFrontendApiFp(this.configuration).dataRequestsClientLocationsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Submits a new data request
     * @param {DataRequestClient} dataRequestClient 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IrisClientFrontendApi
     */
    public dataRequestsClientLocationsPost(dataRequestClient: DataRequestClient, options?: any) {
        return IrisClientFrontendApiFp(this.configuration).dataRequestsClientLocationsPost(dataRequestClient, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Detail view for Data Request with the data submissions already received
     * @param {string} code The unique code of a data request in format of a UUID sent by the health department.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IrisClientFrontendApi
     */
    public getLocationDetails(code: string, options?: any) {
        return IrisClientFrontendApiFp(this.configuration).getLocationDetails(code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} searchKeyword The search keyword
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IrisClientFrontendApi
     */
    public searchSearchKeywordGet(searchKeyword: string, options?: any) {
        return IrisClientFrontendApiFp(this.configuration).searchSearchKeywordGet(searchKeyword, options).then((request) => request(this.axios, this.basePath));
    }
}


